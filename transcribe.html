<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Whisper chunk test</title>
<style>
  body{font-family:ui-sans-serif,system-ui;margin:24px}
  textarea{width:100%;min-height:160px}
  pre{background:#f4f4f5;border:1px solid #e4e4e7;border-radius:8px;padding:10px;overflow:auto}
  button{padding:10px 14px;border-radius:10px;border:1px solid #e4e4e7;background:#fff;cursor:pointer}
  select{padding:8px;border-radius:8px}
</style>
</head>
<body>
<h1>Whisper chunked streaming test</h1>
<p>Use this page to verify the serverless endpoint works.</p>

<label>Language:
<select id="lang">
  <option value="fr">fr</option>
  <option value="nl">nl</option>
  <option value="en">en</option>
  <option value="es">es</option>
</select>
</label>
<br/><br/>
<button id="rec">Record</button>
<h3>Transcript</h3>
<textarea id="out" placeholder="Transcribed text…"></textarea>
<h3>Chunk log</h3>
<pre id="log"></pre>

<script>
const $ = id => document.getElementById(id);
const btn = $('rec'), out = $('out'), log = $('log'), lang=$('lang');
let rec, chunks=[], running=false, timer=null;

function addLog(s){ log.textContent += s + '\n'; log.scrollTop = log.scrollHeight; }

btn.onclick = async () => {
  if(running){ stop(); return; }
  try{
    const stream = await navigator.mediaDevices.getUserMedia({audio:true});
    const mime = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') ? 'audio/webm;codecs=opus' : 'audio/webm';
    rec = new MediaRecorder(stream,{mimeType:mime, audioBitsPerSecond:96000});

    rec.ondataavailable = e => { if(e.data && e.data.size>0) chunks.push(e.data); };

    rec.onstop = async () => {
      clearInterval(timer);
      await flush();
      addLog('⏹️ Stopped & flushed');
      running=false; btn.textContent='Record';
    };

    rec.start(250); // collect small internal blobs
    running=true; btn.textContent='Stop';

    // every 5s push a chunk
    timer = setInterval(async ()=>{
      if(!chunks.length) return;
      await flush();
    }, 5000);

    addLog('▶️ Recording started');
  }catch(e){ alert('Mic error: '+(e.message||e)); }
};

async function flush(){
  const blob = new Blob(chunks, {type: rec.mimeType});
  chunks = [];
  if(!blob.size) return;
  const sizeKB = (blob.size/1024).toFixed(1);

  const form = new FormData();
  form.append('audio', blob, 'chunk.webm');
  form.append('lang', lang.value);

  const t0 = performance.now();
  const res = await fetch('/api/transcribe-chunk', { method:'POST', body: form });
  const json = await res.json();
  const dt = (performance.now()-t0).toFixed(0);

  if(json.text){
    out.value += (out.value.trim()? ' ' : '') + json.text;
    addLog(`✅ Chunk (${sizeKB} KB) → +${json.text.length} chars in ${dt} ms`);
  }else{
    addLog(`⚠️ Chunk (${sizeKB} KB) → error: ${json.error||'unknown'}`);
  }
}

function stop(){ try{rec && rec.stop();}catch{} }
</script>
</body>
</html>
